import type { Asset, ContentSourceInterface, Document, User, InitOptions, Model, UpdateOperation, UpdateOperationField, ValidationError, Version, Schema, ContentChanges } from '@stackbit/types';
import { FileSystemContentSourceOptions } from './fs-content-source';
import { DocumentContext, AssetContext } from './content-converter';
export type GitContentSourceOptions = FileSystemContentSourceOptions & {
    /**
     * When working in local development mode, the GitContentSource will not push
     * changes to the remote git repository to prevent accidental content changes
     * in the production data.
     *
     * Setting the `localDevSync` object, will push content changes made in the
     * local visual editor to the remote git repository.
     *
     * The `localDevSync` object needs to include three properties: `repoUrl`,
     * `repoBranch`, and `repoPublishBranch`.
     */
    localDevSync?: LocalDevSyncOptions;
};
export type LocalDevSyncOptions = {
    /**
     * Set `repoUrl` to the remote git URL you wish to the updated content
     * to be pushed to.
     */
    repoUrl: string;
    /**
     * Set `repoBranch` to the remote git branch you wish the updated
     * content to be pushed to.
     */
    repoWorkingBranch: string;
    /**
     * Set `repoPublishBranch` to the remote git branch you wish to publish
     * the content to. When clicking the "publish" button in the visual
     * editor, the changes from `repoWorkingBranch` will be merged into
     * `repoPublishBranch`.
     */
    repoPublishBranch: string;
};
export declare class GitContentSource implements ContentSourceInterface<unknown, unknown, DocumentContext, AssetContext> {
    private readonly fileSystemContentSource;
    private readonly rootPath;
    private projectUrl;
    private environment;
    private git;
    private cache;
    private localDev;
    private logger;
    private localDevSync?;
    private syncRemote;
    protected isGitCms: boolean;
    constructor(options: GitContentSourceOptions);
    getVersion(): Promise<Version>;
    init(options: InitOptions<unknown, DocumentContext, AssetContext>): Promise<void>;
    destroy(): Promise<void>;
    reset(): Promise<void>;
    private getCommitAuthor;
    private getCommitMessage;
    getContentSourceType(): string;
    getProjectId(): string;
    getProjectEnvironment(): string;
    getProjectManageUrl(): string;
    onWebhook(data: {
        data: unknown;
        headers: Record<string, string>;
    }): void;
    onFilesChange?({ updatedFiles }: {
        updatedFiles: string[];
    }): Promise<{
        invalidateSchema?: boolean;
        contentChanges?: ContentChanges<DocumentContext, AssetContext>;
    }>;
    private onGitPull;
    startWatchingContentUpdates(): void;
    stopWatchingContentUpdates(): void;
    getSchema(): Promise<Schema>;
    getDocuments(): Promise<Document<DocumentContext>[]>;
    getAssets(): Promise<Asset<AssetContext>[]>;
    getAssetFilePath(asset: Asset): string | undefined;
    getDocumentFilePath(document: Document<DocumentContext>): string;
    hasAccess(options: {
        userContext?: User;
    }): Promise<{
        hasConnection: boolean;
        hasPermissions: boolean;
    }>;
    createDocument(options: {
        updateOperationFields: Record<string, UpdateOperationField>;
        model: Model;
        locale?: string | undefined;
        defaultLocaleDocumentId?: string | undefined;
        userContext?: User;
    }): Promise<{
        documentId: string;
    }>;
    updateDocument(options: {
        document: Document<DocumentContext>;
        operations: UpdateOperation[];
        userContext?: User;
    }): Promise<void>;
    deleteDocument(options: {
        document: Document<DocumentContext>;
        userContext?: User;
    }): Promise<void>;
    uploadAsset(options: {
        url?: string | undefined;
        base64?: string | undefined;
        fileName: string;
        mimeType: string;
        locale?: string | undefined;
        userContext?: User;
    }): Promise<Asset<AssetContext>>;
    validateDocuments(options: {
        documents: Document<DocumentContext>[];
        assets: Asset<AssetContext>[];
        locale?: string | undefined;
        userContext?: User;
    }): Promise<{
        errors: ValidationError[];
    }>;
    publishDocuments(options: {
        documents: Document<DocumentContext>[];
        assets: Asset<AssetContext>[];
        userContext?: User;
    }): Promise<void>;
    private getGitChange;
    private getChangesMap;
}
//# sourceMappingURL=git-content-source.d.ts.map